<html>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=yes">
<meta charset="utf-8"/>
<head>
<title>Guitar Friend</title>
<style>
/****************************************************************************/
/* TAB style */

/* Style the tab */
.tab {
  overflow: hidden;
  border: 1px solid rgb(245, 245, 245);/*rgb(125, 214, 243);*/
  background-color: rgb(245, 245, 245);/*lightblue;*/
}

/* Style the buttons that are used to open the tab content */
.tab button {
  background-color: inherit;
  float: left;
  border: none;
  outline: none;
  cursor: pointer;
  padding: 14px 16px;
  transition: 0.3s;
}

/* Special for the settings TAB */
#tab-settings {
    float: right;
    font-size: 27px;
    padding: 6px 16px 5px;
}

/* Change background color of buttons on hover */
.tab button:hover {
  background-color: rgb(235, 235, 235);/*rgb(125, 190, 211);*/
}

/* Create an active/current tab class */
.tab button.active {
  background-color: rgb(220, 220, 220);/*rgb(55, 138, 165);*/
}

/* Style the tab content */
.tab-page {
  display: none;
  padding: 3px 3px;
  /*border: 1px solid rgb(125, 214, 243);
  border-top: none;*/
  /*display: block;*/
  /*height: 100%;*/
}

/****************************************************************************/
/* Settings style */

.settings-title {
    font-weight: bold;
    margin-top: 5px;
    margin-bottom: 5px;
    font-size: 20px;
}

#tab-settings-page button {
    margin-left: 5px;
}

/****************************************************************************/
/* Misc style */
#chord-notes {
    display: inline;
}

.chord-chart {
    margin-top: 5px;
}
.chord-chart:hover {
    cursor: grab;
}

</style>
</head>
<script>

//////////////////////////////////////////////////////////////////////////
// Misc

var globChordNotes = [];

window.onload = function() {
    tabSetup();
    chordSetup();
    savedChordSetup();
    settingsSetup();
    updateDisplay();
    window.onresize = updateDisplay;
}

function updateDisplay() {
    drawGuitarNotes("guitar-canvas");
    drawGuitarNotes("chord-guitar-canvas", globChordNotes);
}

//////////////////////////////////////////////////////////////////////////////
// Sound - currently not used

function playSound(frequency, type) {
    var audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    // create Oscillator node
    var oscillator = audioCtx.createOscillator();

    oscillator.type = type;
    oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime); // value in hertz
    oscillator.connect(audioCtx.destination);
    oscillator.start();    
    oscillator.stop(0.3);    
}

//////////////////////////////////////////////////////////////////////////////
// TAB notes

function drawGuitarNotes(canvasId, noteFilter = []) {
    var canvas = document.getElementById(canvasId);
    var parentStyle = window.getComputedStyle(canvas.parentElement);
    canvas.width = parseFloat(parentStyle.width);

    var ctx = canvas.getContext("2d");

    // Misc constants
    const STRING_SPACE = 25;
    const STRING_COUNT = settingsGetTuningNotes().length;
    const FRET_SPACE = 60;
    const FRET_COUNT = Math.floor(canvas.width / FRET_SPACE) - 1;
    canvas.height = STRING_SPACE * (STRING_COUNT + 2);

    //////////////////////////////////////////////////////////////////////////
    // Draw strings
    ctx.strokeStyle = "black";
    ctx.lineWidth = 1;

    for (var string = 0; string < STRING_COUNT; string++) {
        ctx.beginPath();
        ctx.moveTo(FRET_SPACE, STRING_SPACE * (string + 1));
        ctx.lineTo(FRET_SPACE * (FRET_COUNT + 1), STRING_SPACE * (string + 1));
        ctx.stroke();  
    }

    //////////////////////////////////////////////////////////////////////////
    // Draw fret lines
    for (var fret = 1; fret <= (FRET_COUNT + 1); fret++) {
        ctx.beginPath();
        ctx.moveTo(FRET_SPACE * fret, STRING_SPACE);
        ctx.lineTo(FRET_SPACE * fret, STRING_SPACE * STRING_COUNT);
        ctx.stroke();  
    }

    //////////////////////////////////////////////////////////////////////////
    // Thicker line on fret 0
    const FRET_0_WIDTH = 3;
    ctx.beginPath();
    ctx.rect(FRET_SPACE - FRET_0_WIDTH, STRING_SPACE, 
             FRET_0_WIDTH, STRING_SPACE * (STRING_COUNT - 1));
    ctx.stroke();  
    ctx.fill();     


    //////////////////////////////////////////////////////////////////////////
    // Draw fret markers
    ctx.fillStyle = "black";
    GLOB_FRET_MARKERS.forEach(function(fret) {
        if (fret <= FRET_COUNT) {
            ctx.beginPath();
            ctx.arc(fret * FRET_SPACE + (FRET_SPACE / 2), 
                    STRING_COUNT * STRING_SPACE + STRING_SPACE, 
                    Math.round(STRING_SPACE * 0.1), 0, 2 * Math.PI);
            ctx.stroke();
            ctx.fill();             
        }
    });

    //////////////////////////////////////////////////////////////////////////
    // Write note text
    for (var string = 0; string < STRING_COUNT; string++) {
        for (var fret = 0; fret < (FRET_COUNT + 1); fret++) {
            var centerX = FRET_SPACE * fret + FRET_SPACE / 2;
            var centerY = STRING_SPACE * (string + 1);

            var note = noteAt(fret, string);
            var octave = octaveAt(fret, string);

            if (noteFilter.length != 0) {
                if (noteFilter.indexOf(note) == -1) 
                    continue; // Filtered out
            }

            var backgroundColor= "white";
            var textColor = "black";
            switch (note) {
                case "A":
                    backgroundColor = "lightblue"; 
                    break; 
                case "B":
                    backgroundColor = "lightgreen"; 
                    break; 
                case "C":
                    backgroundColor = "lightpink"; 
                    break; 
                case "D":
                    backgroundColor = "lightgray"; 
                    break; 
                case "E":
                    backgroundColor = "lightyellow"; 
                    break; 
                case "F":
                    backgroundColor = "fuchsia"; 
                    break; 
                case "G":
                    backgroundColor = "lightsalmon"; 
                    break; 
            }
            ctx.beginPath();
            ctx.fillStyle = backgroundColor;
            var noteText = note;
            if (note.includes("/")) {
                var rectWidth = Math.round(FRET_SPACE * 0.8);
                var rectHeight = Math.round(STRING_SPACE * 0.8);
                ctx.rect(centerX - (rectWidth / 2), centerY - (rectHeight / 2), rectWidth, rectHeight);
                ctx.font = Math.round(STRING_SPACE * 0.4) + "px Arial";
            } else {
                ctx.arc(centerX, centerY, Math.round(STRING_SPACE * 0.45), 0, 2 * Math.PI);
                ctx.font = Math.round(STRING_SPACE * 0.5) + "px Arial";
                noteText = note + octave;
            }
            ctx.stroke();
            ctx.fill();

            ctx.fillStyle = textColor; 
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(noteText, centerX, centerY);
        }
    }


}

//////////////////////////////////////////////////////////////////////////////
// TAB chords

// Defines which notes to used based on chord type.
const GLOB_CHORD_TYPES = {
    "major" : {
        "suffix"   : "",
        "interval" : [4, 7]
    },
    "minor" : {
        "suffix"   : "m",
        "interval" : [3, 7]
    },
    "augmented" : {
        "suffix"   : "aug",
        "interval" : [4, 8]
    },
    "diminished" : {
        "suffix"   : "dim",
        "interval" : [3, 6]
    },
    "suspended 2" : {
        "suffix"   : "sus2",
        "interval" : [2, 7]
    },
    "suspended 4" : {
        "suffix"   : "sus4",
        "interval" : [5, 7]
    },
    "major 7" : {
        "suffix"   : "7",
        "interval" : [4, 7, 10]
    },
    "minor 7" : {
        "suffix"   : "m7",
        "interval" : [3, 7, 10]
    },
    "diminished 7" : {
        "suffix"   : "dim7",
        "interval" : [3, 6, 9]
    }
};

// Get involved notes in a chord
function chordNotes(rootNote,chordType) {
    var result = [rootNote];
    GLOB_CHORD_TYPES[chordType]["interval"].forEach(function(noteOffset){
        result.push(noteAtOffset(rootNote, noteOffset));
    });
    return result;
}

// Get number of fingers required for the chord chart
function chordChartNumberOfFingers(strings) {
    const STRING_COUNT = strings.length;
    var nbrFingers = 0;
    for (string = 0 ; string < STRING_COUNT; string++) {
        var fret = strings[string];
        if (fret > 0) {
            nbrFingers++;
        }
    }
    var firstStringFret = strings[0];
    if (firstStringFret > 0) {
        // Check if barre chord
        var isBarre = true;
        for (string = 1 ; string < STRING_COUNT; string++) {
            var fret = strings[string];
            var endBarre = false;
            if ((fret > 0) && (fret < firstStringFret)) {
                // This is not a barre chord
                isBarre = false;
                break;
            }
            if ((endBarre == false) && (fret > -1) && (fret != firstStringFret)) {
                endBarre = true;
            } else if ((endBarre == true) && (fret > 0)) {
                // This is not a barre chord
                isBarre = false;
                break;  
            }
        }
        if (isBarre) {
            for (string = 1 ; string < STRING_COUNT; string++) {
                var fret = strings[string];
                if (fret == firstStringFret) {
                    nbrFingers--;
                }
                else if ((fret > -1) && (fret < firstStringFret)) {
                    // End of barre chord
                    break
                }
            }           
        }
    }
    return nbrFingers;
}

// Get complexity of chord chart. Used when comparing / sorting
// the chord charts.
//
// High value means high complexity. 0 is no complexity which is
// all playable and open strings.
function chordChartComplexity(strings) {
    const STRING_COUNT = strings.length;

    // Many fingers more complex
    var numberOfFingers = chordChartNumberOfFingers(strings)
    var complexity = numberOfFingers;

    if ((strings[0] == -1) && (strings[STRING_COUNT - 1] == -1))
        complexity += 10; // Starting and ending with non-played string
    else if (strings[0] == -1)
        complexity += 5; // Ending with non-played string
    else if (strings[STRING_COUNT - 1] == -1)
        complexity += 1; // Starting with non-played string

    // Check spread of fingers
    if (numberOfFingers > 0) {
        var lowestFret = 9999;
        var highestFret = 1;
        for (string = 0 ; string < STRING_COUNT; string++) {
            var fret = strings[string];
            if (fret > 0) {
                if (fret < lowestFret)
                    lowestFret = fret;
                if (fret > highestFret)
                    highestFret = fret;
            }
        }
        var fretDiff = highestFret - lowestFret;
        if (fretDiff >= 3) {
            complexity += 2;
        }
    }

    return complexity;
}

function chordChartCompare(strings1, strings2) {
    return chordChartComplexity(strings1) - chordChartComplexity(strings2);
}

// Recursive function that returns a list of arrays with
// same length of the matrix where each array is a unique
// combination elements in the matrix.
function permutations(matrix, startIndex) {
    var result = [];
    if (matrix.length > (startIndex + 1)) {
        var subsets = permutations(matrix, startIndex + 1);
        for (var i = 0 ; i < matrix[startIndex].length ; i++) {
            for (var j = 0; j < subsets.length; j++) {
                result.push([matrix[startIndex][i]].concat(subsets[j]));
            }
        }
    } else {
        // Leaf node
        for (var i = 0 ; i < matrix[startIndex].length ; i++) {
            result.push([matrix[startIndex][i]]);
        }
    }

    return result;
}

// Returns a list of all possible chordCharts
function chordChartFinder(notes, minFret, maxFret, rootNoteFirst) {
    const TUNING_NOTES = settingsGetTuningNotes();
    const STRING_COUNT = TUNING_NOTES.length;
    const BASE_NOTE = notes[0];

    // Allowed fret positions
    var allowedFrets = [0]; // Open is always allowed
    for (var fret = minFret; fret <= maxFret; fret++) {
        allowedFrets.push(fret);
    }
    
    // Find out all possible fret positions on each string
    var possibleFrets = [];
    for (var string = 0; string < STRING_COUNT; string++) {
        var possible = [-1]; // Not played always allowed
        allowedFrets.forEach(function(fret) {
            var noteAtFret = noteAt(fret, string);
            if(notes.indexOf(noteAtFret) > -1) {
                possible.push(fret);
            }
        });
        possibleFrets.push(possible);
    }

    // All possible chord permutations
    var possiblePermutations = permutations(possibleFrets, 0);
    var acceptedPermutations = possiblePermutations;

    // Only keep permutations starting with -1 or base note on
    // at minium string with index 1
    var baseNotePermutations = [];
    for (var i=0;i < acceptedPermutations.length;i++) {
        for (string = (STRING_COUNT - 1) ; string > 0; string--) {
            var fret = acceptedPermutations[i][string];
            if (fret >= 0) {
                var noteAtFret = noteAt(fret, string);
                if (noteAtFret == BASE_NOTE) {
                    baseNotePermutations.push(acceptedPermutations[i]);
                }
                break; 
            }
        }
    }  
    if (rootNoteFirst) {
        acceptedPermutations = baseNotePermutations;
    }

    // Only keep permutations where all notes are represented
    var allNotesPermutations = [];
    for (var i=0;i < acceptedPermutations.length;i++) {
        var nonUsedNotes = [...notes];
        for (string = 0 ; string < STRING_COUNT; string++) {
            var fret = acceptedPermutations[i][string];
            if (fret >= 0) {
                var noteAtFret = noteAt(fret, string);
                var index = nonUsedNotes.indexOf(noteAtFret);
                if (index >= 0) {
                    nonUsedNotes.splice(index, 1);
                    if (nonUsedNotes.length == 0) {
                        // All there - ok
                        allNotesPermutations.push(acceptedPermutations[i]);
                        break;
                    }
                }
            }
        }
    }
    acceptedPermutations = allNotesPermutations;

    // Remove permutations that has non-played strings (-1)
    // between two playable strings
    var playablePermutations = [];
    for (var i = 0; i < acceptedPermutations.length;i++) {
        var firstPlayable = 0;
        for (string = 0 ; string < STRING_COUNT; string++) {
            var fret = acceptedPermutations[i][string];
            if (fret != -1) {
                firstPlayable = string;
                break;
            }
        }
        var lastPlayable = 0;
        for (string = (STRING_COUNT - 1) ; string >= 0; string--) {
            var fret = acceptedPermutations[i][string];
            if (fret != -1) {
                lastPlayable = string;
                break;
            }
        }
        var subset = acceptedPermutations[i].slice(firstPlayable, lastPlayable - firstPlayable + 1);
        if (subset.indexOf(-1) == -1) {
            // This is valid
            playablePermutations.push(acceptedPermutations[i]);
        }
    }
    acceptedPermutations = playablePermutations;

    // Remove all permutations that requires more than 4 fingers
    var fourFingerPermutations = [];
    for (var i = 0; i < acceptedPermutations.length;i++) {
        if (chordChartNumberOfFingers(acceptedPermutations[i]) < 5) {
            fourFingerPermutations.push(acceptedPermutations[i]);
        }
    }
    acceptedPermutations = fourFingerPermutations;

    // Sort according to complexity
    acceptedPermutations.sort(chordChartCompare);

    return acceptedPermutations;

}

// As chordChartFinder but possible to limit the space between
// highest and lowest fret.
function chordChartFinderMultiplePos(notes, minFret, maxFret, maxFretSpace, rootNoteFirst) {
    var chordCharts = [];
    for (var startFret = minFret; startFret <= (maxFret - maxFretSpace); startFret++) {
        var cc = chordChartFinder(notes, startFret, startFret + maxFretSpace - 1, rootNoteFirst);
        for (var i = 0; i < cc.length; i++) {
            // Check if already exists
            var duplicate = false;
            for (var j = 0; j < chordCharts.length; j++) {
                if (cc[i].join(",") == chordCharts[j].join(",")) {
                    duplicate = true;
                    break;
                }
            }
            if (duplicate == false) {
                chordCharts.push(cc[i]);
            }
        }
    }
    return chordCharts;
}

// Strings is an array where length equals number of strings.
// -1 means do not play
// 0 means open
// 1 means press fret 1
// ..
// x means press fret x
//
// Index 0 corresponds to highest string (highest pitch)
//
// Returns a canvas object
function chordChart(label,strings) {
    const STRING_SPACE = 15;
    const STRING_COUNT = strings.length;
    const STRING_OFFSET_LEFT = STRING_SPACE / 2;
    const STRING_OFFSET_RIGHT = STRING_SPACE * 2;
    const FRET_SPACE = 20;
    const FRET_COUNT = 4;
    const FRET_OFFSET = FRET_SPACE * 1.5;
    const WIDTH = STRING_SPACE * (STRING_COUNT - 1) + STRING_OFFSET_LEFT + STRING_OFFSET_RIGHT;
    const HEIGHT = FRET_OFFSET + FRET_SPACE * FRET_COUNT + FRET_SPACE / 2;


    //////////////////////////////////////////////////////////////////////////
    // Figure out start fret and "re offset" to fit FRET_COUNT frets
    var minFret = 9999;
    var maxFret = 0;
    strings.forEach(function(string){
        if (string > 0) {
            if (string < minFret) {
                minFret = string;
            }
            if (string > maxFret) {
                maxFret = string;
            }
        }
    });
    var nbrFrets = maxFret - minFret + 1;
    if (nbrFrets > FRET_COUNT) {
        alert("More than " + FRET_COUNT + " frets not supported! Value: " + nbrFrets);
    }
    const FRET_START = Math.max(0, maxFret - FRET_COUNT + 1);
    if (FRET_START > 1) {
        // Move frets (make a copy) to not alter the original object
        strings = [...strings];
        for (var string = 0; string < strings.length; string++) {
            if (strings[string] > 0) {
                strings[string] -= (FRET_START - 1);
            }
        }
    }

    //////////////////////////////////////////////////////////////////////////
    // Draw canvas
    var canvas = document.createElement("canvas");
    canvas.width = WIDTH;
    canvas.height = HEIGHT;
    canvas.setAttribute("class", "chord-chart")
    var ctx = canvas.getContext("2d");


    //////////////////////////////////////////////////////////////////////////
    // Draw label
    ctx.font = Math.round(FRET_OFFSET * 0.6) + "px Arial";
    ctx.fillStyle = "black"; 
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(label, STRING_OFFSET_LEFT + (WIDTH - STRING_OFFSET_LEFT - STRING_OFFSET_RIGHT) / 2, FRET_OFFSET * 0.3);

    //////////////////////////////////////////////////////////////////////////
    // Draw fret marker 
    if (FRET_START > 1) {
        ctx.font = Math.round(FRET_OFFSET * 0.25) + "px Arial";
        ctx.fillStyle = "black"; 
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";
        ctx.fillText(FRET_START + "fr", WIDTH - STRING_OFFSET_RIGHT*0.8, FRET_OFFSET + FRET_SPACE / 2);
    }

    //////////////////////////////////////////////////////////////////////////
    // Draw string markers
    ctx.font = Math.round(FRET_OFFSET * 0.35) + "px Arial";
        ctx.textAlign = "center";
    for (var string = 0; string < STRING_COUNT; string++) {
        var text = "";
        switch(strings[string]) {
            case -1:
                text = "x";
                break;
            case 0:
                text = "o"
        }
        ctx.fillText(text, STRING_OFFSET_LEFT + STRING_SPACE * (STRING_COUNT - 1) - STRING_SPACE * string, 
                     FRET_OFFSET*0.8);
    }

    //////////////////////////////////////////////////////////////////////////
    // Thicker line on fret 0
    ctx.beginPath();
    ctx.rect(STRING_OFFSET_LEFT, FRET_OFFSET - 1, WIDTH - STRING_OFFSET_LEFT - STRING_OFFSET_RIGHT, 2);
    ctx.stroke();  
    ctx.fill();     

    //////////////////////////////////////////////////////////////////////////
    // Draw strings
    for (var string = 0; string < STRING_COUNT; string++) {
        ctx.beginPath();
        ctx.moveTo(STRING_OFFSET_LEFT + string * STRING_SPACE, FRET_OFFSET);
        ctx.lineTo(STRING_OFFSET_LEFT + string * STRING_SPACE, FRET_OFFSET + FRET_SPACE * FRET_COUNT);
        ctx.stroke();        
    }

    //////////////////////////////////////////////////////////////////////////
    // Draw frets
    for (var fret = 0; fret < (FRET_COUNT + 1); fret++) {
        ctx.beginPath();
        ctx.moveTo(STRING_OFFSET_LEFT, FRET_OFFSET + FRET_SPACE * fret);
        ctx.lineTo(STRING_OFFSET_LEFT + (STRING_COUNT - 1) * STRING_SPACE,  FRET_OFFSET + FRET_SPACE * fret);
        ctx.stroke();        
    }

    //////////////////////////////////////////////////////////////////////////
    // Draw "dots"
    for (var string = 0; string < STRING_COUNT; string++) {
        var fret = strings[string];
        if (fret > 0) {
            ctx.beginPath();
            ctx.arc(STRING_OFFSET_LEFT + STRING_SPACE * (STRING_COUNT - 1) - STRING_SPACE * string, 
                    FRET_OFFSET + FRET_SPACE * fret - FRET_SPACE / 2, 
                    Math.round(STRING_SPACE * 0.3), 0, 2 * Math.PI);
            ctx.stroke(); 
            ctx.fill();
        }       
    }

    //////////////////////////////////////////////////////////////////////////
    // Draw barre line (when possible)
    var barreFret = strings[0];
    if (barreFret > 0) {
        var lastString = 0;
        for (var string = 1; string < STRING_COUNT; string++) {
            if (strings[string] < barreFret) {
                break;
            }
            if (strings[string] == barreFret) {
                lastString = string;
            }
        }
        if (lastString > 0) {
            ctx.beginPath();
            ctx.rect(WIDTH - STRING_OFFSET_RIGHT - STRING_SPACE * lastString, 
                     FRET_OFFSET + FRET_SPACE * barreFret - FRET_SPACE / 2 - 1, 
                     lastString*STRING_SPACE, 2);
            ctx.stroke(); 
            ctx.fill();
        }
    }

    return canvas;    
}

function chordSetup() {
    var rootNote = URLSearchParamGet("root_note");
    var chordType = URLSearchParamGet("chord_type");
    var rootNotePos = URLSearchParamGet("root_note_pos");

    // Update chord root note selection
    var rootNoteSelect = document.getElementById("chord-select-root-note");
    GLOB_NOTES.forEach(function (note) {
        var elemOption = document.createElement("option");
        elemOption.setAttribute("value", note);
        elemOption.innerText = note;
        if (rootNote == note)
            elemOption.setAttribute("selected", "");
        rootNoteSelect.appendChild(elemOption);
    });
   
    // Update chord root note selection
    var chordTypeSelect = document.getElementById("chord-select-type");
    for (type in GLOB_CHORD_TYPES) {
        var elemOption = document.createElement("option");
        elemOption.setAttribute("value", type);
        elemOption.innerText = type;
        if (chordType == type)
            elemOption.setAttribute("selected", "");
        chordTypeSelect.appendChild(elemOption);
    }

    // Select saved correct root note pos
    var rootNotePosSelect = document.getElementById("chord-select-root-note-pos");
    var options = rootNotePosSelect.getElementsByTagName("option");
    for (var option of options) {
        if (option.getAttribute("value") == rootNotePos) {
            option.setAttribute("selected", "");
        }
    }

    chordSelect();
}

function chordSelect() {
    var rootNote = document.getElementById("chord-select-root-note").value;
    var chordType = document.getElementById("chord-select-type").value;
    var rootNotePos = document.getElementById("chord-select-root-note-pos").value;

    // Save
    URLSearchParamSet("root_note", rootNote, false);
    URLSearchParamSet("chord_type", chordType, false);
    URLSearchParamSet("root_note_pos", rootNotePos, false);

    var notes = chordNotes(rootNote,chordType);
    var chordNotesElem = document.getElementById("chord-notes");
    chordNotesElem.innerText = notes;
    var chordCharts = chordChartFinderMultiplePos(notes, 1, 24, 4, rootNotePos == "first");
    var label = rootNote;
    if (rootNote.includes("/"))
        label = rootNote.split("/")[0];
    label = label + GLOB_CHORD_TYPES[chordType]["suffix"];
    var chordsPage = document.getElementById("chord-charts");
    chordsPage.innerHTML = ""; // Remove all old charts
    chordCharts.forEach(function(strings) {
        var chordChartCanvas = chordChart(label,strings);
        chordChartCanvas.onclick = function() {
            savedChordsAdd(label, strings);
        }
        chordsPage.appendChild(chordChartCanvas, notes);
    });
    globChordNotes = notes; // Needed for guitar notes
    updateDisplay();
}

//////////////////////////////////////////////////////////////////////////////
// TAB saved

function savedChordsLoad() {
    var result = [];
    var saved = URLSearchParamGet("saved", "").split("|");
    if (saved == "")
        saved = [];
    saved.forEach(function(chord){
        var s = chord.split(";");
        var entry = {};
        entry["label"] = s[0];
        entry["strings"] = s[1].split(",").map(function(item) {
            return parseInt(item, 10);
        });
        result.push(entry);
    });
    return result;
}

function savedChordsSave(entries, reloadPage) {
    var entriesStr = [];
    entries.forEach(function(entry){
            entriesStr.push(entry["label"] + ";" + entry["strings"].join(","));
        });
    URLSearchParamSet("saved", entriesStr.join("|"), reloadPage);
}

function savedChordsAdd(label, strings) {
    var entries = savedChordsLoad();
    var isDuplicate = false;
    entries.forEach(function(entry){
        if ((label == entry["label"]) && (strings.join(",") == entry["strings"].join(","))) {
            isDuplicate = true;
        }
    });
    if (isDuplicate == false) {
        var newEntry = {
            "label"   : label,
            "strings" : strings
        };
        entries.push(newEntry);
        savedChordsSave(entries, false);
    }
    URLSearchParamSet("tab_selected", "tab-saved", true); // Go to saved page
}

function savedChordsRemoveAll() {
    URLSearchParamSet("saved", "", true);
}

function savedChordsRemove(label, strings) {
    var entries = savedChordsLoad();
    var removeIndex = -1;
    for (var i = 0; i < entries.length ; i++) {
        if ((label == entries[i]["label"]) && 
            (strings.join(",") == entries[i]["strings"].join(","))) {
            removeIndex = i;
            break;
        }
    }
    if (removeIndex >= 0) {
        entries.splice(removeIndex, 1);
        savedChordsSave(entries, true);
    }
}

function savedChordSetup() {
    var entries = savedChordsLoad();
    var savedChordsPage = document.getElementById("saved-chord-charts");
    entries.forEach(function(entry){
        var chordChartCanvas = chordChart(entry["label"],entry["strings"]);
        chordChartCanvas.onclick = function() {
            savedChordsRemove(entry["label"], entry["strings"]);
        }
        savedChordsPage.appendChild(chordChartCanvas);
    });
    if (entries.length == 0) 
        document.getElementById("saved-chord-charts-remove").disabled = true;
}


//////////////////////////////////////////////////////////////////////////////
// TAB settings

const GLOB_STD_TUNINGS = {
    "Guitar - standard" : {
        "notes"   : "E,B,G,D,A,E",
        "octaves" : "4,3,3,3,2,2"
    },
    "Guitar - 8 string" : {
        "notes"   : "E,B,G,D,A,E,B,F♮/G♭",
        "octaves" : "4,3,3,3,2,2,1,1"
    },
    "Ukelele" : {
        "notes"   : "A,E,C,G",
        "octaves" : "4,4,4,4"
    },
    "Bass" : {
        "notes"   : "G,D,A,E",
        "octaves" : "2,2,1,1"
    }
};
const GLOB_NOTES = ["C", "C♮/D♭", "D", "D♮/E♭", "E", "F", "F♮/G♭", "G", "G♮/A♭","A", "A♮/B♭", "B"];
const GLOB_FRET_MARKERS = [3, 5, 7, 9, 12, 15, 17, 19, 21, 24];

function noteAtOffset(rootNote, offset) {
    var index = GLOB_NOTES.indexOf(rootNote);
    index = (index + offset) % GLOB_NOTES.length;
    return GLOB_NOTES[index];
}

// fret 0 = no open string
// string 0 = lowest string (highest pitch)
function noteAt(fret, string) {
    var firstNote = settingsGetTuningNotes()[string];
    return noteAtOffset(firstNote, fret);
}

// fret 0 = no open string
// string 0 = lowest string (highest pitch)
function octaveAt(fret, string) {
    var firstNote = settingsGetTuningNotes()[string];
    var firstOctave = parseInt(settingsGetTuningOctaves()[string]);
    var index = GLOB_NOTES.indexOf(firstNote);
    var octaveOffset = Math.floor((index + fret) / GLOB_NOTES.length);
    return firstOctave + octaveOffset;
}

function settingsSetup() {
    const TUNING_NOTES = settingsGetTuningNotes();
    const TUNING_OCTAVES = settingsGetTuningOctaves();
    const STRING_COUNT = TUNING_NOTES.length;

    // Update Tuning selection
    var tuningSelect = document.getElementById("tuning-select");
    var useCustom = true;
    for (tuning in GLOB_STD_TUNINGS) {
        var elemOption = document.createElement("option");
        elemOption.setAttribute("value", tuning);
        elemOption.innerText = tuning;
        if (GLOB_STD_TUNINGS[tuning]["notes"]   == TUNING_NOTES.join(",") &&
            GLOB_STD_TUNINGS[tuning]["octaves"] == TUNING_OCTAVES.join(",")) {
            elemOption.setAttribute("selected", "");
            useCustom = false;
        }
        tuningSelect.appendChild(elemOption);
    }
    if (useCustom) {
        var elemOption = document.createElement("option");
        elemOption.setAttribute("value", "Custom");
        elemOption.innerText = "Custom";
        elemOption.setAttribute("selected", "");
        tuningSelect.appendChild(elemOption);
    }

    // Update Tuning table
    var tuningTable = document.getElementById("tuning-table");
    for (var string = 0 ; string < STRING_COUNT; string++) {
        var elemRow = document.createElement("tr");

        // Cell: String
        var elemCell = document.createElement("td");
        elemCell.innerText = string + 1;
        elemRow.appendChild(elemCell);

        // Cell: Note
        elemCell = document.createElement("td");
        var elemSelect = document.createElement("select");
        elemSelect.setAttribute("onchange", "settingsUpdateTuningNotes()");
        elemSelect.setAttribute("class", "tuning-table-note");
        GLOB_NOTES.forEach(function (note) {
            var elemOption = document.createElement("option");
            elemOption.setAttribute("value", note);
            elemOption.innerText = note;
            if (note == TUNING_NOTES[string]) {
                elemOption.setAttribute("selected", "");
            }
            elemSelect.appendChild(elemOption);
        });
        elemCell.appendChild(elemSelect);
        elemRow.appendChild(elemCell);

        // Cell: Octave
        elemCell = document.createElement("td");
        var elemInput = document.createElement("input");
        elemInput.setAttribute("onchange", "settingsUpdateTuningOctaves()");
        elemInput.setAttribute("class", "tuning-table-octave");
        elemInput.setAttribute("type", "number");
        elemInput.setAttribute("min", "0");
        elemInput.setAttribute("max", "9");
        elemInput.setAttribute("value", TUNING_OCTAVES[string]);

        elemCell.appendChild(elemInput);
        elemRow.appendChild(elemCell);

        tuningTable.appendChild(elemRow);
    }
}

function settingsTuningSelect() {
    var tuning = document.getElementById("tuning-select").value;
    if (tuning != "Custom") {
        settingsSetTuning(GLOB_STD_TUNINGS[tuning]["notes"].split(","),
                          GLOB_STD_TUNINGS[tuning]["octaves"].split(","));
    }
}

function settingsUpdateTuningNotes() {
    var elements = document.getElementsByClassName("tuning-table-note");
    tuningNotes = []
    for (var i = 0; i < elements.length; i++) {
        tuningNotes.push(elements[i].value);
    }
    URLSearchParamSet("tuning_notes", tuningNotes.join(","), true);
}

function settingsUpdateTuningOctaves() {
    var elements = document.getElementsByClassName("tuning-table-octave");
    tuningOctaves = []
    for (var i = 0; i < elements.length; i++) {
        tuningOctaves.push(elements[i].value);
    }
    URLSearchParamSet("tuning_octaves", tuningOctaves.join(","), true);
}

function settingsTuningRemoveString() {
    var notes = settingsGetTuningNotes();
    var octaves = settingsGetTuningOctaves();
    if (notes.length > 1) {
        notes.pop();
        octaves.pop();
        settingsSetTuning(notes, octaves);
    }
}

function settingsTuningAddString() {
    var notes = settingsGetTuningNotes();
    var octaves = settingsGetTuningOctaves();
    notes.push(GLOB_NOTES[0]);
    octaves.push("2");
    settingsSetTuning(notes, octaves);
}

function settingsTuningReset() {
    const params = new URLSearchParams(window.location.search);
    params.delete("tuning_notes");
    params.delete("tuning_octaves");
    // Will reload page and replace history
    window.location.search = params.toString();   
}

function settingsSetTuning(notes, octaves) {
    const params = new URLSearchParams(window.location.search);
    params.set("tuning_notes", notes.join(","));
    params.set("tuning_octaves", octaves.join(","));
    // Will reload page and replace history
    window.location.search = params.toString();         
}

function settingsGetTuningNotes() {
    var value = URLSearchParamGet("tuning_notes", GLOB_STD_TUNINGS["Guitar - standard"]["notes"]);
    return value.split(",");
}

function settingsGetTuningOctaves() {
    var value = URLSearchParamGet("tuning_octaves", GLOB_STD_TUNINGS["Guitar - standard"]["octaves"]);
    return value.split(",");
}

//////////////////////////////////////////////////////////////////////////////
// TAB page general handling

function tabSetup() {
    tabShow(URLSearchParamGet("tab_selected", "tab-notes"));

    var tabButtons = document.getElementsByClassName("tab-button");
    for (var i = 0; i < tabButtons.length ; i++) {
        tabButton = tabButtons[i];
        tabButton.setAttribute("onclick", "tabShow(\"" + tabButton.id + "\")");
    }
}

function tabShow(tabId) {
    // Show the correct tab
    tabPages = document.getElementsByClassName("tab-page");
    for (var i = 0 ; i < tabPages.length ; i++) {
        tabPage = tabPages[i];
        if(tabPage.id == tabId + "-page")
            tabPage.style.display = "block";
        else
            tabPage.style.display = "none";
    }

    // Mark the active button
    tabButtons = document.getElementsByClassName("tab-button");
    for (var i = 0; i < tabButtons.length ; i++) {
        tabButton = tabButtons[i];
        if (tabButton.id == tabId)
            tabButton.className += " active";
        else 
            tabButton.className = tabButton.className.replace(" active", "");
    }

    // Remember the selected tab
    URLSearchParamSet("tab_selected", tabId, false);

    // Redraw everything
    updateDisplay();
}

//////////////////////////////////////////////////////////////////////////////
// URL search parameters

// Get value of URL search parameter, or default value if it don't exist
function URLSearchParamGet(key, defaultValue) {
    const params = new URLSearchParams(window.location.search);

    if (params.has(key)) {
        return params.get(key);
    }
    return defaultValue;
}

// Set value of URL search parameter. Optionally reload page
function URLSearchParamSet(key, value, reloadPage) {
    const params = new URLSearchParams(window.location.search);
    params.set(key, value);
    if (reloadPage) {
        // Will reload page and replace history
        window.location.search = params.toString(); 
    } else {
        // Just replace history
        history.replaceState({},value,"?" + params.toString());        
    }
}


</script>
<body>

    <div class="tab">
        <button class="tab-button" id="tab-notes">NOTES</button>
        <button class="tab-button" id="tab-chords">CHORDS</button>
        <button class="tab-button" id="tab-saved">SAVED</button>
        <button class="tab-button" id="tab-settings">&#9881;</button>
    </div>

    <!----------------------------------------------------------------------------------->
    <!-- Tones TAB -->
    <div class="tab-page" id="tab-notes-page">
        <canvas id="guitar-canvas"></canvas>
    </div>

    <!----------------------------------------------------------------------------------->
    <!-- Chords TAB -->
    <div class="tab-page" id="tab-chords-page">
        <div>
            <select id="chord-select-root-note" onchange="chordSelect()"></select>
            <select id="chord-select-type" onchange="chordSelect()"></select>
            <select id="chord-select-root-note-pos" onchange="chordSelect()">
                <option value="first" selected>Root note first</option>
                <option value="anywhere">Root anywhere (ukelele style)</option>
            </select>
            <div id="chord-notes"></div>
        </div>
        <div id="chord-charts"></div>
        <canvas id="chord-guitar-canvas"></canvas>
    </div>

    <!----------------------------------------------------------------------------------->
    <!-- Saved TAB -->
    <div class="tab-page" id="tab-saved-page">
        <div id="saved-chord-charts"></div>
        <button id="saved-chord-charts-remove" onclick="savedChordsRemoveAll()">Remove all</button>
    </div>

    <!----------------------------------------------------------------------------------->
    <!-- Settings TAB -->
    <div class="tab-page" id="tab-settings-page">
        <div class="settings-group">
            <div class="settings-title">Tuning</div>
            <select id="tuning-select" onchange="settingsTuningSelect()"></select>
            <table id="tuning-table">
                <tr id="tuning-table-heading">
                    <th>String</th>
                    <th>Note</th>
                    <th>Octave</th>
                </tr>
            <table>
            <button onclick="settingsTuningReset()">Reset to standard</button>
            <button onclick="settingsTuningAddString()">Add string</button>
            <button onclick="settingsTuningRemoveString()">Remove string</button>
        </div>
    </div>

</body>
</html>